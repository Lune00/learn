--TRIGGER -- NOTIONS ET EXERCICES

-- 1. Evenements de base de données

--Comportement de la VUE: 
CREATE OR REPLACE VIEW v_manager
    AS SELECT * FROM emp 
    WHERE job='MANAGER';
    
SELECT * FROM v_manager;

--On peut faire un INSERT dans une vue mais que si elle ne fait reference
--qu'a une table sans jointure. Dans ce cas aucune ambiguité sur la cible du INSERT
INSERT INTO v_manager(empno,ename,deptno)
    VALUES('4234','Jean-Michel',10);
COMMIT;

--On pourrait mettre un trigger sur la vue pour dire, si tu INSERT sur la vue
--qui recupere les managers tu lui associes le job de MANAGER.



-- Exercice : Un trigger enregistre dans une table d'archivage
--l'ancien salaire d'un employé quand il est modifié, avec sa date de modification

CREATE TABLE t_archive(code NUMBER,nom varchar2(20),ancienSalaire NUMBER(7,2),
                       dateModificationSalaire DATE);
                       
--Declaration d'un TRIGGER                       
CREATE OR REPLACE TRIGGER tr_HistoriseSalaire
    AFTER UPDATE OF sal ON emp FOR EACH ROW   
    BEGIN
    INSERT INTO t_archive 
        VALUES(:OLD.empno,:OLD.ename,:OLD.sal,sysdate);
END;
/

UPDATE emp SET sal=5000 WHERE ename='SMITH';


-- Exercice : dans la table departement, redondance de données avec
-- une colonne nombre d'employés dans la table. Mettre en place un trigger
-- qui met a jour automatiquement les valeurs dans cette colonne

--Agit sur delete ou update ou insert
CREATE OR REPLACE TRIGGER tr_update_NbEmployes
    AFTER UPDATE OF deptno OR INSERT OR DELETE ON emp
    FOR EACH ROW
    BEGIN
    
    IF INSERTING THEN
    --le :New fait reference a la ligne qui a été INSERT
      UPDATE dept SET nbemp=nbemp+1 WHERE deptno=:NEW.deptno ;
    ElSIF DELETING THEN
    --le :Old fait reference a la ligne qui a été DELETE
       UPDATE dept SET nbemp=nbemp-1 WHERE deptno=:OLD.deptno ;
    ELSIF UPDATING THEN -- change de departement
    --le :New et :Old font reference a la ligne qui a été UPDATE
      UPDATE dept SET nbemp=nbemp+1 WHERE deptno=:NEW.deptno ;
        UPDATE dept SET nbemp=nbemp-1 WHERE deptno=:OLD.deptno ;
    END IF;
    
END;
/
--TESTS:
INSERT INTO emp(EMPNO,ename,deptno) VALUES(2222,'Jeannot',20);
UPDATE emp SET deptno=40 WHERE ename='Jeannot';
SELECT * FROM dept;



---- Exercice: Mettre en place un TRIGGER qui interdit le delete d'un emp
---- si il est MANAGER
--
--CREATE OR REPLACE TRIGGER avoidDeleteManager
--    BEFORE DELETE ON emp
--    FOR EACH ROW
--       
--    DECLARE 
--        DELETE_MANAGER EXCEPTION;
--    BEGIN
--     IF (:OLD.job = 'MANAGER') THEN
--        RAISE DELETE_MANAGER;
--    END IF;
--     
--     EXCEPTION
--        WHEN DELETE_MANAGER THEN
--        DBMS_OUTPUT.put_line('Impossible de supprimer un MANAGER');
--        --Comment faire remonter le ROLLBACK du trigger a l'evenement?
--        --Pas possible? Il faudrait mettre le DELETE dans un bloc
--        --supérieur qui gererait l'exception. On ferait une procédure
--        --stockée avec un parametre qui prend l'employé a supprimer
--        --Dans ce bloc on déclarerait le trigger. Et la on pourrait
--        --faire une gestion d'erreur propre et empecher le delete
--        --sans avoir recours a un RAISE_APPLICATION_ERROR
--        --TODO!!
--      
--END;
--/

DELETE emp WHERE job='MANAGER' AND ename='BLAKE' ;

--Exercice precedent, suggestion avec le WHEN de TRIGGER
--Solution pas non plus satisfaisante
CREATE OR REPLACE TRIGGER avoidDeleteManager
    BEFORE DELETE ON emp
    FOR EACH ROW
    WHEN (OLD.job='MANAGER') --mettre OLD et non :OLD dans le WHEN()
    BEGIN
    RAISE_APPLICATION_ERROR(-20001,'Impossible de supprimer un Manager.');
    
END;
/

CREATE OR REPLACE TRIGGER avoidDeleteManager
    BEFORE DELETE ON emp
    FOR EACH ROW
       
    DECLARE 
        DELETE_MANAGER EXCEPTION;
    BEGIN
     IF (:OLD.job = 'MANAGER') THEN
        RAISE DELETE_MANAGER;
    END IF;
END;
/
--Il faut declarer l'exception dans un package (acces global au trigger
--et a la procedure)....
CREATE OR REPLACE PROCEDURE deleteEmploye(empName emp.ename%type) IS
BEGIN
    DELETE emp WHERE ename=empName;

    EXCEPTION
        WHEN DELETE_MANAGER THEN
         DBMS_OUTPUT.put_line('Impossible de supprimer un MANAGER');
END;
/

-- TRIGGER sur une VIEW

--Exercices: si j'INSERT dans la vue, le job doit etre initialisé a MANAGER.
-- Le trigger doit venir completer l'insert.
-- Sur une vue, le INSTEAD OF dit qu'on jouera le trigger a la place de l'INSERT 
CREATE OR REPLACE TRIGGER tr_add_manager 
    INSTEAD OF INSERT ON v_manager
    FOR EACH ROW
    BEGIN
    --NE pas faire sur la VIEW mais sur la table direct
    --sinon boucle recursive
    INSERT INTO emp(empno,ename,job,sal,deptno)
    VALUES(:NEW.empno,:NEW.ename,'MANAGER',2200,:NEW.deptno);
    END;
/


CREATE OR REPLACE VIEW v_manager
    AS SELECT * FROM emp 
    WHERE job='MANAGER';


SELECT * FROM v_manager;
INSERT INTO v_manager(empno, ename, deptno)
    VALUES(1556,'Filibert',40);





