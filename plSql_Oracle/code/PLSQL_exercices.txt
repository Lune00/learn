-- Exercice : Modifier le salaire de SMITH. Une fois modifié, 
--  afficher avec DBMS son nom et son nouveau salaire.
-- PAS OPTIMAL, voir solution ci-dessous avec RETURNING au UPDATE
DECLARE
v_sal emp.sal%type;
BEGIN
SELECT sal INTO v_sal FROM emp WHERE ename='SMITH';
DBMS_OUTPUT.PUT_LINE('Ancien salaire : '||v_sal);
UPDATE emp SET sal=2*sal WHERE ename='SMITH';
COMMIT;
SELECT sal INTO v_sal FROM emp WHERE ename='SMITH';
DBMS_OUTPUT.PUT_LINE('Nouveau salaire : '||v_sal);
END;

-- Suggestion: pas optimal, deux select (un pour modifier, un pour lire)
--  Pour parer à ca, RETURNING sous la ligne UPDATE
DECLARE
v_sal emp.sal%type;
BEGIN

SELECT sal INTO v_sal FROM emp WHERE ename='SMITH';
DBMS_OUTPUT.PUT_LINE('Ancien salaire : '||v_sal);
UPDATE emp SET sal=sal/2 WHERE ename='SMITH' 
    RETURNING sal INTO v_sal;
COMMIT;
DBMS_OUTPUT.PUT_LINE('Nouveau salaire : '||v_sal);
END;

-- Faire un bloc PL/SQL pour savoir si chaque employé 
-- a une commission COMM
DECLARE

CURSOR c_COMM IS SELECT * FROM emp;

BEGIN

FOR i IN c_COMM LOOP
IF i.comm IS NOT NULL THEN
 DBMS_OUTPUT.PUT_LINE(i.ename||' a une commission('||i.comm||')');   
ELSE
 DBMS_OUTPUT.PUT_LINE(i.ename||' n''a pas de commission.'); 
END IF;
END LOOP;

END;
/


-- Atelier 3 - Exercices

-- 1. Afficher le salaire d'un employé. Si l'employé n'existe pas
--    lever une exception qui affiche 'Employé inexistant'
--DECLARE
--
--    v_emp_name emp.ename%type:='SMITH';
--    --CURSOR c_emp(v_nom emp.ename%type) IS SELECT sal FROM emp WHERE ename=v_nom;
--    --EMP_DO_NOT_EXIST EXCEPTION;
--    v_sal_emp emp.sal%type;
--
--BEGIN
--
--    SELECT sal INTO v_sal_emp FROM emp WHERE ename=v_emp_name;
--     DBMS_OUTPUT.put_line('Nom: '||v_emp_name||' Salaire: '||v_sal_emp);
--
--EXCEPTION
--    WHEN NO_DATA_FOUND THEN
--        DBMS_OUTPUT.put_line('Employé inexistant');
--
--
--END;
--/


-- 2. Augmenter le salaire d'un employé, si un nouveau salaire dépasse
-- celui du KING, lever une excetion avec un message 'Pas Possible'


DECLARE

    v_emp_name emp.ename%type:='SMITH';
    v_sal_emp emp.sal%type;
    v_emp_new_sal emp.sal%type:=15000;
    v_KING_sal emp.sal%type;

    SALARY_GREATER_THAN_KING EXCEPTION;

BEGIN

    SELECT sal INTO v_KING_sal FROM emp WHERE ename='KING';
    --Recuperer le nom de l'emp qui a le salaire le plus important
    --SELECT ename FROM emp WHERE SELECT MAX(sal) FROM emp;

    SELECT sal INTO v_sal_emp FROM emp WHERE ename=v_emp_name;
    DBMS_OUTPUT.put_line('Nom: '||v_emp_name||' Salaire: '||v_sal_emp);
    DBMS_OUTPUT.put_line('Nouveau salaire: '||v_emp_new_sal);
    DBMS_OUTPUT.put_line('Salaire de KING: '||v_king_sal);
    
    IF v_emp_new_sal > v_KING_sal THEN
        RAISE SALARY_GREATER_THAN_KING;
    ELSE
     UPDATE emp SET sal=v_emp_new_sal WHERE ename=v_emp_name; 
     DBMS_OUTPUT.put_line('Salaire de '||v_emp_name||' mis à jour('||
                    v_sal_emp||'->'||v_emp_new_sal||')');
     COMMIT;
    END IF;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.put_line('Employé inexistant');
     WHEN SALARY_GREATER_THAN_KING THEN
        DBMS_OUTPUT.put_line('Le salaire de '||v_emp_name||' ne peut pas exceder le salaire du KING');

END;
/
             
-- 3. Inserer un nouveau département 'MATH APPLIQUEE'. Lever une exception
--    avec le message 'VALEUR TROP GRANDE'. Utiliser PRAGMA
     
DECLARE
    --v_name_dept dept.dname%type:='MATH APPLIQUEE';
    DNAME_TOO_LONG EXCEPTION;
    PRAGMA EXCEPTION_INIT(DNAME_TOO_LONG,-12899);

BEGIN

    INSERT INTO dept VALUES(60,'MATHS APPLIQUEES','BOSTON');
    EXCEPTION
        WHEN DNAME_TOO_LONG THEN
        DBMS_OUTPUT.put_line('Nom du département trop long');
    
END;
/


--VUE/JOINTURE

--A la creation de la vue, stocke en mémoire le résultat du SELECT.
CREATE OR REPLACE VIEW v_nb_emp
    AS SELECT dept.deptno, dept.dname, count(*) AS nb
    FROM emp INNER JOIN dept
    ON emp.deptno = dept.deptno
    GROUP BY dept.deptno,dept.dname;
    
--Utilisation de la vue, va direct chercher en mémoire
SELECT * FROM v_nb_emp;



-- Tests sur les jointures

SELECT * FROM emp INNER JOIN dept ON emp.deptno = dept.deptno  ;

-- RETOURNE le produit cartesien des deux tables (toutes les combinaisons).
-- Chaque ligne d'une table sera associée avec chaque ligne d'une autre table
SELECT * FROM emp CROSS JOIN dept ;
     

--Exercice : met a jour le nombre de clients / departement
-- Amelioration de perfs (base décisionelle) si le select du nombre d'employés est regulierement
-- consulté. En décisionnel la perf est privilégiée, on prefere faire de la redondance
-- de données (comme ici, stocker le nombre d'employés)

--ALTER TABLE dept ADD(nbemp number(2) default 0);

DECLARE
CURSOR c_nb IS SELECT dept.deptno, dept.dname, count(*) AS nb 
    FROM emp INNER JOIN dept
    ON emp.deptno = dept.deptno
    GROUP BY dept.deptno,dept.dname;
BEGIN

FOR i IN c_nb LOOP
UPDATE dept SET nbemp=i.nb WHERE deptno = i.deptno;
END LOOP;

END;



